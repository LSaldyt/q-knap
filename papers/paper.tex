\documentclass{article}

\usepackage{indentfirst}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{pgfplotstable}
\doublespacing

% ================================================================================= 
% Package for showing source code
% ================================================================================= 

 \usepackage{listings}
  \usepackage{courier}
 \lstset{
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         %numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
         keywordstyle=\color{red},
            frame=b,         
 %        keywordstyle=[1]\textbf,    % Stil der Keywords
 %        keywordstyle=[2]\textbf,    %
 %        keywordstyle=[3]\textbf,    %
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         stringstyle=\color{blue}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         %backgroundcolor=\color{lightgray},
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
 }
 \lstloadlanguages{% Check Dokumentation for further languages ...
         %[Visual]Basic
         %Pascal
         %C
         %C++
         %XML
         %HTML
         %Java
         Python
 }
    %\DeclareCaptionFont{blue}{\color{blue}} 

  %\captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
  \usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% ================================================================================= 
% Package for flowcharts/diagrams
% ================================================================================= 

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io}        = [rectangle, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=blue!30]
\tikzstyle{process}   = [diamond, minimum width=2cm, minimum height=0cm, text centered, draw=black, fill=orange!30]
\tikzstyle{arrow}     = [thick,->,>=stealth]

% ==================================================
% Paper
% ==================================================

\title{Quantum Programming Interfaces for NP-complete problems}
\date{05-10-2017}
\author{Lucas Saldyt}

\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}

% ==================================================
\section{Abstract}
% ==================================================

Programming a quantum annealer to solve certain kinds of NP-complete problems is actually very simple.
Because of the rich software toolchains surrounding the DWave, it is easy to describe problems for the annealer to solve.
This paper compares various implementations of the Knapsack problem: Classically, using the DWave, and using the IBM Quantum Experience.
Formal benchmarking is not a direct part of report. Formal benchmarks have been performed in [citations], and will be taken into account in the analysis of this paper.
[Conclusion recap]

% ==================================================
\section{Introduction}
% ==================================================

The Knapsack problem and other NP-complete problems have immediate real-world applications. 
However, as the size of an NP-complete problem increases, it becomes very difficult to solve.
Quantum Computation can allow NP-complete problems to be solved with a polynomial speedup.
This paper explores different interfaces in the hope of improving the availability of quantum computation, and demonstrating the ease of use of existing interfaces.

\newpage

% ==================================================
\section{Methods}
% ==================================================

% --------------------------------------------------
\subsection{Classical Knapsack Implementations}
% --------------------------------------------------

% .................................................. 
\subsubsection{Naive Implementation}
% .................................................. 

The simplest interface for solving the knapsack problem is a naive python implementation that iterates through every combination of items, and returns the combination with the highest value that satisfies the problem's constraints.
\lstset{language=Python}
\lstinputlisting[label=samplecode,caption=Naive Knapsack]{../scripts/naive.py}
However, the effectiveness of this implementation is limited, and only useful for showing how the code scales with different solvers.
\newpage

% .................................................. 
\subsubsection{Dynamic Programming Implementation}
% .................................................. 

Traditionally, the optimal way to solve the knapsack is through dynamic programming.
However, the code necessary is more difficult to write from scratch:

\lstset{language=Python}
\lstinputlisting[label=samplecode,caption=Dynamic Programming]{../scripts/dynamic.py}
\newpage

% .................................................. 
\subsubsection{Fully Polynomial Approximation Scheme Implementation}
% .................................................. 

However, a fully polynomial approximation scheme is more accurately comparable to the problem being run on the DWave.
A FPTAS simplifies the problem given, solving it to within a margin of error.
After simplification, FPTAS uses dynamic programming.
For problems with few variables, the results of FPTAS are very similar to the results of dynamic programming, even if the margin of error is allowed to be high.
Notice that the fptas solver calls the dynamic programming solver (with a simpler version of the given problem). Even though its implementation appears to be short, it is actually much larger because it includes the dynamic programming code.

\lstset{language=Python}
\lstinputlisting[label=samplecode,caption=Fully Polynomial Time Approximation Scheme]{../scripts/fptas.py}
\newpage

% --------------------------------------------------
\subsection{Quantum Knapsack Implementations}
% --------------------------------------------------

% .................................................. 
\subsubsection{DWave Knapsack Implementations : Verilog}
% .................................................. 

While there are many ways of providing problems to the DWave quantum computer (Such as APIs for Python, C++, or Haskell, or an array of Domain Specific Languages), This paper investigates the highest-level implementations possible for the DWave.
The first way to solve an NP-complete problem on the DWave is to provide a Verilog implementation of a circuit that checks if a solution is correct.
This provides enough information to generate a Quantum Binary Optimization Problem, which the DWave can perform annealing on.
Below are a few implementations of verilog circuits and their corresponding circuit images.

\lstset{language=Verilog}
\lstinputlisting[label=samplecode,caption=Single Constraint Knapsack Problem]{../output/vs/single.v}

\newpage
\begin{figure}
  \includegraphics[width=\linewidth]{../output/circuitimages/single.png}
  \caption{Single constraint circuit representation}
  \label{fig:single}
\end{figure}
To simplify the construction of the Verilog file, one can use additional software:
\begin{enumerate}
    \item{QA-Prolog, a compiler from Prolog to Verilog (shown below)}
    \item{QNP, which includes a script that generates Verilog from a csv file describing the knapsack problem}
\end{enumerate}
\newpage

% .................................................. 
\subsubsection{DWave Knapsack Implementations : Prolog}
% .................................................. 

Using the QA-Prolog software, Prolog can produce similar code to the Verilog shown above.
The single constraint problem, written in Prolog:
\lstset{language=Prolog}
\lstinputlisting[label=samplecode,caption=Single Constraint Knapsack Problem]{../prolog/single.pl}

% .................................................. 
\subsubsection{DWave Knapsack Implementations : CSV}
% .................................................. 

A csv file, which also compiles to the Verilog shown previously:

\pgfplotstabletypeset[
    col sep=comma,
    string type,
    columns/name/.style={column name=Name, column type={|l}},
    columns/surname/.style={column name=Surname, column type={|l}},
    columns/age/.style={column name=Age, column type={|c|}},
    every head row/.style={before row=\hline,after row=\hline},
    every last row/.style={after row=\hline},
    ]{../csvs/single.csv}
\newpage

% .................................................. 
\subsubsection{Theoretical IBM Quantum Experience Knapsack Implementations}
% .................................................. 

Quantum Annealing is not the only alternate method of solving the knapsack problem.
Instead, Universal Gate Quantum Computing offers a polynomial speedup based on Grover's search.

However, the interface for using a Universal Gate Quantum Computer is much different than using a classical computer or the DWave.
By comparison, the DWave interface may as well be classical, since, as this paper has showed, classical languages can be compiled to annealing problems runnable on the DWave.

The language of Universal Gate Quantum computers is, redundantly, Quantum Gates, which are best expressed in qasm files.

[Grover's Search, etc]

% ==================================================
\section{Results}
% ==================================================

Below is output from these three classical solvers on an eight variable knapsack problem:

\begin{verbatim}
fptas : 0.0007245789747685194
{'G', 'B', 'D', 'H', 'E'}
value is satisfied (70)
weight is satisfied (60)
volume is satisfied (55)
________________________________________________________________________________

naive : 0.0013742649462074041
{'G', 'B', 'D', 'H', 'E'}
value is satisfied (70)
weight is satisfied (60)
volume is satisfied (55)
________________________________________________________________________________

dynamic: 0.0006771821063011885
{'G', 'B', 'D', 'H', 'E'}
value is satisfied (70)
weight is satisfied (60)
volume is satisfied (55)
________________________________________________________________________________
\end{verbatim}

Above 8 variables, the naive implementation times out or returns an incorrect answer.

% ==================================================
\section{Discussion}
% ==================================================

Which interface is simplest? Easiest to use?
Simple interface must be justified: If it isn't useful for solving problems, then the simplicity of the interface doesn't matter.
Even if a simpler interface works for certain kinds of problems, be careful when making claims.

Cite other benchmarks, don't do many.

% ==================================================
\section{Appendix}
% ==================================================

\begin{thebibliography}{9}
    \bibitem{gps}
        A. Newell, J. C. Shaw, H. A. Simon
        \textit{Report on a general problem-solving program}
        The Rand corporation, Santa Monica, California, 1958
\end{thebibliography}

\end{document}
